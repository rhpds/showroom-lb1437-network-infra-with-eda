= Network configuration with Ansible

It's the next morning, and even though our (most recent) crisis has been averted, the way you fixed that router wasn't sustainable. We can do better than manually copying and pasting configs in the middle of the night.

[#iac]
== Infrastructure as Code

We'll be making use of Network Resource Modules, which differ from other module designs you may have worked with in Ansible.

[NOTE]
====
Ansible network resource modules simplify and standardize how you manage different network devices. Network devices separate configuration into sections (such as interfaces and VLANs) that apply to a network service. Ansible network resource modules take advantage of this to allow you to configure subsections or _resources_ within the network device configuration. Network resource modules provide a consistent experience across different network devices.

https://docs.ansible.com/ansible/latest/network/user_guide/network_resource_modules.html[Ansible Documentation]
====

In the file explorer on the left side of your VSCode environment, expand the `playbooks` folder, then click on `configure_ios_routing.yml` to open it.

This is a playbook that applies a minimal configuration to a router in our lab. Let's dig into a few things about this playbook:

* The hosts line
 ** Later in the lab, Event-Driven Ansible (EDA) is going to identify which devices in our lab have had their configurations changed. We want to be able to only run remediation on devices that we know need it, which is what the `ansible_eda` variable is for.
 ** We don't have EDA involved yet, so `ansible_eda` is not defined, and we'll therefore default to rtr1 and rtr2 for now.
* The resource state
 ** For the sake of this lab, we're using state `merged`, which is the least destructive state we can use, and is recommended for testing.
 ** You can check out the document on Resource Modules linked above for a description of the available states and why you'd want to use each one. The `replaced` state, for example, would wipe out any configuration in the relevant subsection _not_ found in the resource data, which is helpful for compliance and drift control.
* The resource data
 ** The module inputs are very minimal, as they reference variable data. This data can be found under the `host_vars` directory within `playbooks`.
 ** Take a moment to expand the `host_vars` directory, then expand `rtr1` and/or `rtr2`. Each resource has its own file. The files relevant to us right now are `bgp_global.yml` and `interfaces.yml` since they contain the variables used in our playbook. Collapse `host_vars` again before moving on.

This playbook and its resource data represent an *Infrastructure as Code* approach to managing the configuration on our two routers. This will be our *source of truth* for this lab's network configuration. In other words, we want to treat this code as the definitive answer to what the router configurations should be, regardless of what's currently applied. If you want to make a change, you modify the source of truth, not the device directly.

Let's run this playbook a couple of times.

For our first run, use the following command (using `-vv` for verbosity level 2):

[source,bash,role=execute]
----
ansible-navigator run playbooks/configure_ios_routing.yml -vv
----

We should see the first task report `ok` - so nothing changed. But the in the second task's output, you should see something like below:

[source,textinfo]
----
changed: [rtr1] \=> {"after": {"as_number": "65000", "bgp": {"default": {"ipv4_unicast": true, "route_target": {"filter": true}}, "log_neighbor_changes": true, "router_id": {"address": "192.168.1.1"}}, "neighbors": [{"neighbor_address": "10.200.200.2", "remote_as": "65001"}]}, "before": {"as_number": "65000", "bgp": {"default": {"ipv4_unicast": true, "route_target": {"filter": true}}, "log_neighbor_changes": true, "router_id": {"address": "192.168.1.1"}}, "neighbors": [{"neighbor_address": "10.200.200.2", "remote_as": "65001"}]}, "changed": true, "commands": ["router bgp 65000", "timers bgp 5 15"]}
----

Refer to the `commands` output at the end (scroll all the way right in the box above) to see that the resource module was able to figure out which commands needed to be run to accomplish the configuration, even though our configuration data is stored as YAML. We were only missing the `timers` part. This is for the lab so that BGP can more quickly tell when something is wrong, and we'll be making use of that later.

Run the playbook again and drop the verbosity:

[source,bash,role=execute]
----
ansible-navigator run playbooks/configure_ios_routing.yml
----

This time both of the tasks report `ok`. This means that our live configuration still matches our source of truth. It also means that the playbook is *idempotent*, meaning that we can run this playbook as many times as we want without applying any change, as long as the configuration stays correct.

[#recover]
== Recovering from a misconfiguration

Time to break things. Let's start by logging into `rtr1` over SSH and looking at the output of a couple commands. Run the following:

[source,bash,role=execute]
----
ssh rtr1
----

[source,bash,role=execute]
----
show ip interface brief
----

Expected output:

[source]
----
rtr1#show ip interface brief 
Interface              IP-Address      OK? Method Status                Protocol
GigabitEthernet1       172.16.147.219  YES DHCP   up                    up      
Loopback0              192.168.1.1     YES manual up                    up      
Tunnel0                10.100.100.1    YES manual up                    up      
Tunnel1                10.200.200.1    YES manual up                    up      
VirtualPortGroup0      192.168.35.101  YES TFTP   up                    up      
----

We can see that all of the interfaces on the router are up, including `Tunnel0`, which we identified earlier as being involved in OSPF. Let's look at that next. Run the following:

[source,bash,role=execute]
----
show ip ospf neighbor
----

Expected output:

[source]
----
rtr1#show ip ospf neighbor 

Neighbor ID     Pri   State           Dead Time   Address         Interface
192.168.3.3       0   FULL/  -        00:00:30    10.100.100.2    Tunnel0
----

Again we see the importance of `Tunnel0`. What happens if `Tunnel0` gets shut down? Let's find out. Run the following commands:

[source,role=execute]
----
configure terminal
interface Tunnel0
shutdown
end
----

Check to see that the interface came down:

[source,bash,role=execute]
----
show ip interface brief
----

Expected output:

[source]
----
rtr1#show ip interface brief
Interface              IP-Address      OK? Method Status                Protocol
GigabitEthernet1       172.16.147.219  YES DHCP   up                    up      
Loopback0              192.168.1.1     YES manual up                    up      
Tunnel0                10.100.100.1    YES manual administratively down down    
Tunnel1                10.200.200.1    YES manual up                    up      
VirtualPortGroup0      192.168.35.101  YES TFTP   up                    up       
----

And see its effect on OSPF:

[source,role=execute]
----
show ip ospf neighbor
----

You get no output from running this command, which is not good. We should turn `Tunnel0` back on. But, rather than doing that manually, we should be able to have Ansible get us back to a known-good state. Exit out of the SSH session and run the configuration playbook that we were running before.

[source,role=execute]
----
exit
----

[source,bash,role=execute]
----
ansible-navigator run playbooks/configure_ios_routing.yml
----

We should get `changed` reported only on rtr1 and only on the interface configuration task.

[source]
----
[student@ansible-1 telemetry]$ ansible-navigator run playbooks/configure_ios_routing.yml

PLAY [Configure IOS Routing] **********************************************************************************

TASK [Apply interfaces config] ********************************************************************************
ok: [rtr2]
changed: [rtr1]

TASK [Apply BGP Global config] ********************************************************************************
ok: [rtr1]
ok: [rtr2]

PLAY RECAP ****************************************************************************************************
rtr1                       : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
rtr2                       : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
----

SSH back into rtr1 and check the interface state again.

[source,bash,role=execute]
----
ssh rtr1
----

[source,bash,role=execute]
----
show ip interface brief
----

[source,role=execute]
----
show ip ospf neighbor
----

We should see that our state is back to normal. This shows us that we can use this playbook to recover from misconfiguration issues.

Exit your SSH session before moving on.

[source,role=execute]
----
exit
----
